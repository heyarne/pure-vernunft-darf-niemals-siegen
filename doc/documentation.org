#+STARTUP: hidestars
#+TITLE: AI for Games and Interactive Systems
#+SUBTITLE: Dokumentation zur Übung 1
#+AUTHOR: Arne Schlüter (538145), Katharina Spangehl (548176)
#+LANGUAGE: de-de
#+LATEX_HEADER: \usepackage[]{babel}

* Einleitung

Dieser Text kommentiert und dokumentiert die Abgabe zur Übung Nummer 1 des Kurses AI for Games and Interactive Systems, geleitet von Prof. Dr. Tobias Lenz an der HTW Berlin im Sommersemester 2018.

Ziel der Übung war es, einen Bot zu programmieren, der in einem vorgegebenen Spiel mit Namen Gawihs möglichst intelligente Züge auswählt und so über den Spielserver gegen andere Spiele antreten kann. Die Zugauswahl sollte mithilfe des Alpha-Beta-Algorithmus erfolgen, der eine erweiterte Version des Minimax-Algorithmus darstellt. Ferner sollte eine dynamische Verbesserung im Laufe einer Entwicklung, die einem genetischen Algorithmus folgt, implementiert werden. Weitere Informationen dazu finden sich im Kapitel [[Implementierung]].

Gegeben war seitens des Dozenten eine Implementierung des Spieleservers und einige Clientbibliotheken, die die Client-Server-Interaktion gestalten sollten. Diese gegebenen Bestandteile wurden als =.jar=-Dateien angeliefert und waren auf der Java Virtual Machine (JVM) auszuführen.

* Wahl der Programmiersprache

Die wohl interessanteste und schwerwiegendste Entscheidung, die im Zusammenhang mit dieser Abgabe gefallen ist, war die Wahl der Programmiersprache Clojure als Basis der Implementierung. Clojure ist ein moderner Lisp-Dialekt, der sich als gehostete Sprache versteht. Das bedeutet, das Clojure keine eigene Laufzeitumgebung mitbringt, sondern sozusagen als Gast in verschiedenen Umgebungen ausgeführt werden kann. Zu diesen Umgebungen gehören neben der Common Language Runtime von .NET und JavaScript VMs auch die JVM, was eine Interaktion mit den bereits gegebenen Programmbestandteile ermöglicht. Trotz einer möglichen Interaktion bietet Clojure allerdings Paradigmen, die sich von denen der Gastgeber stark unterscheiden können:

Eine üblicherweise im Zusammenhang mit LISP-Dialekten genannte Herangehensweise an Entwicklung heißt /REPL Driven Development/. Typischerweise startet man zu Beginn des Entwicklungsprozesses einen Read Eval Print Loop (REPL), an den laufend Programmteile zur Ausführung geschickt werden, um deren Ergebnisse angezeigt zu bekommen und eigene Annahmen so zu belegen oder zu widerlegen. Eine REPL für derartige Sprachen ist häufig über Plugins gut in den verwendeten Texteditor integriert.

Einen weiteren zentralen Bestandteil der Sprache bilden /Functional Persistent Immutable Data Structures/. Die Idee geht unter anderem zurück auf das Paper [[http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf][Purely Functional Persistent Data Structures (Okasaki, 1996)]] und beschreibt Datenstrukturen, die bei Veränderung eine neue Version ihrer selbst zurückgeben, anstatt die alte Version zu zerstören. Anhand eines Beispiels lässt sich das folgendermaßen verdeutlichen[fn:: Dieser Codeblock zeigt eine Interaktion mit einer Clojure REPL. Als Konvention wird jeder Ausdruck einzeln ausgeführt. Mit =;; =>= beginnende Zeilen symbolisieren das Ergebnis einer ausgeführten Instruktion.]:

#+NAME: toy_repl
#+CAPTION: Persistente Datenstrukturen
#+BEGIN_SRC clojure
(def example {:a 1, :b 2})
;; => #'user/example
example
;; => {:a 1, :b 2}
(dissoc example :a)
;; => {:b 2}
example
;; => {:a 1, :b 2}
#+END_SRC

Zuerst wird eine Variable =example= definiert, die dem =Map=-Interface entspricht und Schlüssel auf Werte abbildet. Die Variable wird beispielhaft ausgegeben (Zeilen, die mit =;= beginnen, werden in Clojure als Kommentare interpretiert). Anschließend wird der Schlüssel =:a= aus =example= entfernt und das Ergebnis ausgegeben - der originale Wert bleibt davon jedoch unberührt.

Diese Datenstrukturen fördern den Aufbau eines Programms aus vielen kleinen, puren Funktionen, also Funktionen, die keine Werte außerhalb ihrer selbst verändern, sondern lediglich Berechnungen mit den eingegebenen Parametern anstellen und die Ergebnisse zurückgeben. Persistente Datenstrukturen in Clojure arbeiten mit /Structural Sharing/, das heißt bei einer Veränderung des Wertes wird ein größtmöglicher Teil des alten Wertes wiederverwendet, um Speicher zu sparen. Im Zusammenspiel mit Persistenten Datenstrukturen, die jede Wertveränderung explizit machen, ist ein Umfeld gegeben, das eine schrittweise Näherung an eine Lösung in einem vorher unbekannten Feld gangbar macht.

Ein weiteres vielversprechendes Feature ist /Laziness/, die, ähnlich der Immutability, als Konzept in verschiedenen Programmiersprachen auftaucht. Der Begriff bezeichnet die Eigenschaft von Sprachen, Werte erst dann zu berechnen, wenn sie gebraucht werden. Das ermöglicht Konstrukte wie unendlich große Listen - jeder Knoten liegt erst dann im RAM, wenn nach ihm gefragt wird. Im Hinblick auf eventuell sehr große Spielbäume barg das die Hoffnung, möglichst Speicher einzusparen.

#+NAME: Implementierung
* Implementierung
** Umgebung

Das Projekt wurde entwickelt mit [[https://java.com/en/download/manual.jsp][Java 1.8]], [[https://clojure.org/guides/getting_started][Clojure 1.8]] und [[https://leiningen.org/][Leiningen 2.8.1]]. Leiningen ist ein Build-Tool für Clojure, das dabei hilft, gängige Aufgaben zu automatisieren, ein Projekt zu strukturieren und Abhängigkeiten zu verwalten. Daraus ergibt sich für das vorliegende Projekt ein =src=-Ordner mit sämtlichen Modulen, die in ihrer Gesamtheit die Implementierung des Clients bilden, einen =test=-Ordner, der Unit-Tests beinhaltet und einen =resources=-Ordner, der weitere zugehörige Dateien wie Bilder und die vorgegebenen Bibliotheken enthält. Eine einfache REPL lässt sich mit dem Kommando =lein repl= starten, Tests werden mithilfe des Kommandos =lein test= ausgeführt.

Testen ist in Clojure reibungslos und tief in die Sprache integriert: Die Standardbibliothek kommt mit einem simplen aber mächtigen Testing-Framework in Form von =clojure.test= und sprachbedingt bedeutet ein Test häufig nichts anderes als den Vergleich einer ad-hoc generierten oder manipulierten Datenstruktur und dem Rückgabewert einer Funktion mit einem simplen Gleichheits-Operator. Der ganze Entwicklungsprozess gestaltete sich daher als Mischung aus der Interaktion mit einer tief in den Editor integrierten REPL und kontinuierlich laufenden Tests, die bei der dynamischen Natur der Sprache etwas mehr Zuversicht schenken konnten, das laufende Annahmen über Codeverhalten weiter bestehen. Zusätzlich dazu kommunizieren die geschriebenen Tests diese Annahmen anderen Menschen gegenüber.

** TODO Modellierung des Spiels

Die Logik des Spiels befindet sich im Namespace =ai-for-games.core=[fn:: Die Ordnerstruktur folgt, ähnlich wie bei Java, den Namen der Namespaces. =ai-for-games.core= befindet sich in =src/ai_for_games/core.clj=]. Der Namespace bildet mit =test/ai_for_games/core_test.clj= den am besten getesteten.

Das Spielbrett ist ein multidimensionaler Vektor (=board=). Ist ein Wert im Vektor =nil=, so repräsentiert er ein nicht existentes Feld. Vektoren repräsentieren Felder, auf denen sich Spieler befinden können. Das Feld ist in ein =atom= verpackt, was eine threadsichere Abstraktion für sich ändernde Werte bietet. Auf =atom= sind zwei Operationen definiert, =swap!= und =reset!=. Während =reset!= schlicht einen neuen Wert in das =atom= schreibt, dient =swap!= dazu, den im =atom= befindlichen Wert in einer atomischen Operation in Abhängigkeit des aktuellen Wertes zu ändern.

Die nächsten beiden Funktionen =on-top?= und =valid-starts= definieren bereits grundsätzliche Funktionen, die der Interaktion mit dem Brett dienen. Hier wird bereits die eingangs genannte Tendenz zum Aufbau aus vielen relativ kleinen und puren Funktionen deutlich. Alle validen Startkoordinaten eines Spielers zu Beginn des Spieles lassen sich damit in der REPL folgendermaßen abfragen:

#+BEGIN_SRC clojure
(in-ns 'ai-for-games.core)
(->> (valid-starts @board :g)
     (map idx->coord))
  ;; => ([0 4] [1 5] [2 6] [3 7] [4 8])
#+END_SRC

Leider hat sich in der Spielmodellierung ein Bug eingeschlichen, der auf ein falsches Regelverständnis zurückzuführen ist. =moves-from-cell= schaut sich lediglich die unmittelbaren Nachbarfelder eines Feldes an, von dem aus ein Zug stattfinden soll, und filtert anschließend die ungültigen Züge heraus. Richtig wäre, alle anderen Felder anzuschauen, auf denen ein eigener Stein steht, deren Nachbarfelder zu betrachten und anschließend die gültigen Züge zu prüfen. Eine korrekte Implementierung würde also lauten:

#+BEGIN_SRC clojure
(defn all-neighbors
  [board cell]
  (keep (partial neighbor board cell) directions))

(defn moves-from-cell
  "Gives us all possible moves for a cell"
  [board from-coord player]
  ;; remove the cell we're standing on
  (let [board' (assoc board (coord->idx from-coord) nil)]
    (->>
     board'
     ;; get all cells which contain one of our stones
     (keep-indexed (fn [idx cell] (when (= cell [player]) idx)))
     ;; concatenate with all neighbors
     (mapcat #(all-neighbors board' (idx->coord %)))
     ;; give our possible moves a nice representation
     (map (fn [[cell-coord cell]]
            {:from from-coord :to cell-coord}))
     ;; ... and keep only those that we can go to
     (filter (fn [move]
               (valid-move? board move player))))))
#+END_SRC

** TODO Minimax-Algorithmus
** TODO Genetischer Algorithmus
* TODO Fazit

- Man braucht einen Editor, der mit Clojure umgehen kann (strukturelles editieren & REPL-Integration)
- Paradigmen machen Interop teilweise schwer
- Sehr kompakte Sprache; insgesamt 524 Zeilen Sourcecode (mit Docstrings), wovon mehr als 1/4 (160) auf Tests anfällt
